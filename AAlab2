\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{geometry}
\geometry{left=25mm,right=15mm,top=20mm,bottom=20mm}
\usepackage{setspace}
\setstretch{1.2}

\begin{document}
\begin{titlepage}
    \centering
    \normalsize
    НАЦІОНАЛЬНИЙ ТЕХНІЧНИЙ УНІВЕРСИТЕТ УКРАЇНИ\\
    «КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ ім. Ігоря СІКОРСЬКОГО»\\
    НАВЧАЛЬНО-НАУКОВИЙ ФІЗИКО-ТЕХНІЧНИЙ ІНСТИТУТ
    
    \vfill
    
    \LARGE Звіт з дисципліни «Прикладні алгоритми»\\[2em]
    \LARGE\textbf{РЕАЛІЗАЦІЯ ТИПУ "ГРАФ"}\\[0.4em]
   
    
    \vfill
    
    \begin{flushright}
        \large
        Виконала студентка\\
        групи ФІ-33\\
        Зварунчик Аріна Олександрівна
    \end{flushright}
    
    \vspace{3em}
    Київ — 2025
\end{titlepage}

\tableofcontents 
\newpage

\section{Мета роботи}
Опанувати способи представлення різних типів графів (неорієнтовані, орієнтовані, зважені) та їх ефективної реалізації.

\section{Списки суміжності}
Для виконання лабараторної роботи було обране представлення графу у вигляді списків суміжності,адже це ефективний спосіб для представлення розріджених графів. Кожній вершині відповідає список, що містить інформацію про інші вершини, з якими вона з’єднана безпосередньо.Цей метод є значно економнішим за пам’яттю ніж представлення матрицею суміжності.Також перевагою даного методу є швидкий доступ до сусідніх вершин.


\subsection{Опис абстрактного класу \texttt{Graph}}
\subsubsection*{Поля класу}
\begin{itemize}
    \item \texttt{n} --- кількість вершин графа.
    \item \texttt{adjLists[]} --- масив списків суміжності, де \texttt{adjLists[i]} містить усі сусіди вершини $i$.
\end{itemize}
\subsubsection*{Методи класу}
\begin{itemize}
 \item \texttt{Graph(int vertices)} --- ініціалізація порожнього графа з n вершинами.
    \textbf{Складність:} $\Theta(n)$ .

    \item \texttt{void addVertex()} --- додає нову вершину до графа.  
    
    \textbf{Складність:} $\Theta(1)$.

    \item \texttt{void deleteVertex(int u)} --- видаляє вершину \texttt{u} і всі ребра, пов'язані з нею.  
    
    \textbf{Складність:}$O(n+E)$,$E$-к-ть ребер.

    \item \texttt{int[][] convertToAdjMatrix()} --- конвертує граф зі списку суміжності у матрицю суміжності. 
    
    \textbf{Складність:} $O(n^2)$.

    \item \texttt{void BackAdjMatrix(int[][] adjMatrix)} --- перетворює граф з матриці суміжності у список суміжності.
    
    \textbf{Складність:} $O(n^2)$.


    \item \texttt{void erdosRenyi(int n, float p)} --- генерує випадковий граф у моделі Ердеша-Реньї.  
 
    \textbf{Складність:} $O(n^2)$.
\end{itemize}

\subsection{Клас \texttt{UndirectedGraph}}
Реалізація неорієнтованого графа.

\subsubsection*{Методи класу}
\begin{itemize}
    \item \texttt{void addEdge(int u, int v)} --- додає  ребро між $u$ та $v$. 
    
    \textbf{Складність:}$O(n)$.

    \item \texttt{void deleteEdge(int u, int v)} --- видаляє ребро між $u$ та $v$.  
    
    \textbf{Складність:} $O(n)$.

     \item \texttt{void erdosRenyi(int n, float p)} --- генерує випадковий неорієнтований граф $G(n,p)$.  
     
    \textbf{Складність:} $O(n^2)$.
\end{itemize}

\subsection{Клас \texttt{WeightedUndirected}}
Реалізація зваженого неорієнтованого графа.

\subsubsection*{Методи класу}
\begin{itemize}
    \item \texttt{void addEdge(int u, int v, int weight)} --- додає зважене ребро $u-v$ з вагою $weight$. 
    
    \textbf{Складність:} $O(n)$.

    \item \texttt{void deleteEdge(int u, int v)} --- видаляє ребро $u-v$.  
    
    \textbf{Складність:} $O(n)$.

     \item \texttt{void deleteVertex(int u)} ---  видаляє вершину \texttt{u} і коригує індекси.  
     
    \textbf{Складність:} $\Theta(1)$.

    \item \texttt{int[][] convertToAdjMatrixW()} --- будує матрицю суміжності.  
    
    \textbf{Складність:} $O(n^2)$.

    \item \texttt{void BackAdjMatrixW(int[][] adjMatrix)} --- відновлює граф з  матриці суміжності.  
    
    \textbf{Складність:} $O(n^2)$.

    \item \texttt{void erdosRenyiWeighted(int n, float p, int minWeight, int maxWeight)} --- генерує випадковий зважений граф. 
    
    \textbf{Складність:} $O(n^2)$.
\end{itemize}

\subsection{Клас \texttt{Directed}}
Реалізація орієнтованого графа.

\subsubsection*{Методи класу}
\begin{itemize}
    \item \texttt{void addEdge(int u, int v)} --- додає орієнтоване ребро $u \rightarrow v$.  
    
    \textbf{Складність:} $O(n)$.

    \item \texttt{void deleteEdge(int u, int v)} --- видаляє орієнтоване ребро $u \rightarrow v$.  
    
    \textbf{Складність:} $O(n)$.

\end{itemize}

\subsection{Клас \texttt{WeightedDirected}}
Реалізація зваженого орієнтованого графа.

\subsubsection*{Методи класу}
\begin{itemize}
    \item \texttt{void addEdge(int u, int v, int weight)} --- додає орієнтоване зважене ребро $u \xrightarrow{w} v$.  
    \textbf{Складність:} $O(n)$.

    \item \texttt{void deleteEdge(int u, int v)} --- видаляє орієнтоване зважене ребро $u \xrightarrow{w} v$.
    
    \textbf{Складність:}  $O(n)$.

    \item \texttt{void deleteVertex(int u)} ---  видаляє вершину \texttt{u} та коригує індекси у всіх списках. 
    
    \textbf{Складність:} $\Theta(1)$.

    \item \texttt{int[][] convertToAdjMatrixW()} --- будує матрицю.  


    \textbf{Складність:} $O(n^2)$.

    \item \texttt{void BackAdjMatrixW(int[][] adjMatrix)} --- відновлює з матриці (перебір усіх $i,j$).  
    \textbf{Складність:}$O(n^2)$.

    \item \texttt{void erdosRenyiWeighted(int n, float p, int minWeight, int maxWeight)} --- генерує випадковий зважений орієнтований граф.  
    
    \textbf{Складність:}$O(n^2)$.

\end{itemize}

\subsection{Опис класу \texttt{Test}}
Цей клас призначений для тестування роботи всіх реалізованих графів 
(орієнтованих, неорієнтованих, зважених та незважених), а також для перевірки 
взаємодії з користувацьким інтерфейсом через клас \texttt{PythonGraphClient}.  

\subsection{Опис класу \texttt{Edge}}
Клас використовується для представлення зваженого ребра у графі. 

\subsubsection*{Поля класу}
\begin{itemize}
    \item \texttt{int to} --- вершина, у яку веде ребро.
    \item \texttt{int weight} --- вага ребра.
\end{itemize}

\subsubsection*{Методи класу}
\begin{itemize}
    \item \texttt{Edge(int to, int weight)} --- конструктор, який створює ребро з вказаною вершиною призначення та вагою.  
\end{itemize}

\section{Користувацький інтерфейс}
\texttt{PythonGraphClient}

Призначений для взаємодії з сервером візуалізації графів.Він відправляє дані про вершини та ребра у форматі JSON на python-сервер і отримує зображення графа у відповідь. Потім відкриває вікно (\texttt{Swing JFrame}) для відображення цього зображення.

\texttt{graph\_server.py}

Реалізує сервер, який приймає дані про граф у JSON, будує його за допомогою бібліотеки \texttt{networkx}, малює з використанням \texttt{matplotlib}, і повертає клієнту готове зображення у форматі PNG.

Виклик здійснюється через клас \texttt{Test}:

\begin{verbatim}
WeightedDirected g = new WeightedDirected(4);
g.addEdge(0, 1, 5);
g.addEdge(1, 2, 3);
g.addEdge(2, 3, 7);

try {
    PythonGraphClient.sendGraphAndShowImage(
        g.exportEdgesAsJson(), true, true
    );
} catch (Exception e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(null, 
        "Error sending graph " + e.getMessage());
}
\end{verbatim}
 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Знімок екрана 2025-09-22 о 19.30.35.png}
    \caption{Візуалізація графа, згенерованого через \texttt{PythonGraphClient}}
\end{figure}

\newpage
\section{Мій репозиторій:} 
\href{https://github.com/arinacoola/AppliedAlgorithms/tree/main/lab2}
\end{document}
